Query Module
============

.. contents:: Table of Contents
   :local:
   :depth: 2

Overview
--------

The Query module provides a type-safe, expression-based query interface for LearnQL. It uses C++ expression templates to build SQL-like queries with compile-time type checking and zero-cost abstractions. The query system supports filtering, joins, grouping, and lazy evaluation through batched iteration.

**Key Features:**

- Type-safe query expressions using static Field objects
- Expression template-based predicates (no strings!)
- Lambda predicate support with ``find_if()``
- Join operations (inner join, left join, cross join)
- GroupBy and aggregations
- Memory-efficient batched execution
- Integration with C++20 ranges

**Module Components:**

- ``Field<T, FieldType>`` - Static field descriptors for expressions
- Expression operators: ``==``, ``!=``, ``<``, ``<=``, ``>``, ``>=``, ``&&``, ``||``
- ``Join<T1, T2>`` - Join operations between tables
- ``GroupBy<T, KeyType>`` - Grouping and aggregations
- ``Query<T>`` - Optional query builder pattern

Quick Start
-----------

Basic Filtering with where()
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

.. code-block:: cpp

   #include <learnql/LearnQL.hpp>

   using namespace learnql;

   // Create table
   core::Database db("university.db");
   auto& students = db.table<Student>("students");

   // Simple query using static Field objects
   auto adults = students.where(Student::age >= 18);

   // Iterate results
   for (const auto& student : adults) {
       std::cout << student.get_name() << "\n";
   }

Complex Expressions
~~~~~~~~~~~~~~~~~~~

.. code-block:: cpp

   // Combined with AND
   auto honor_students = students.where(
       (Student::department == "CS") && (Student::gpa >= 3.5)
   );

   // Combined with OR
   auto special = students.where(
       (Student::age < 20) || (Student::gpa >= 3.9)
   );

   // Complex nested expressions
   auto eligible = students.where(
       ((Student::department == "CS") && (Student::gpa > 3.5)) ||
       (Student::age < 20)
   );

Lambda Predicates
~~~~~~~~~~~~~~~~~

.. code-block:: cpp

   // Use lambda for complex logic
   auto cs_high_achievers = students.find_if([](const Student& s) {
       return s.get_department() == "CS" &&
              s.get_gpa() > 3.5 &&
              s.get_age() <= 20;
   });

Static Field Objects
--------------------

Overview
~~~~~~~~

Fields are automatically generated by the ``LEARNQL_PROPERTY`` macro and are used to build type-safe query expressions.

.. code-block:: cpp

   class Student {
       LEARNQL_PROPERTIES_BEGIN(Student)
           LEARNQL_PROPERTY(int, student_id, PK)
           LEARNQL_PROPERTY(std::string, name)
           LEARNQL_PROPERTY(int, age)
           LEARNQL_PROPERTY(double, gpa)
       LEARNQL_PROPERTIES_END(
           PROP(int, student_id, PK),
           PROP(std::string, name),
           PROP(int, age),
           PROP(double, gpa)
       )
   };

   // The macro automatically generates these static Field objects:
   // Student::student_id  (Field<Student, int>)
   // Student::name        (Field<Student, std::string>)
   // Student::age         (Field<Student, int>)
   // Student::gpa         (Field<Student, double>)

Field Class Reference
~~~~~~~~~~~~~~~~~~~~~

.. doxygenstruct:: learnql::query::Field
   :members:

The ``Field`` class represents a typed field accessor used in query expressions.

**Template Parameters:**

- ``T`` - The record type
- ``FieldType`` - The field's data type

**Usage in Expressions:**

.. code-block:: cpp

   // Field objects are used directly in expressions
   Student::age >= 18        // Creates comparison expression
   Student::gpa > 3.5        // Creates comparison expression
   Student::department == "CS"  // String comparison

Expression Templates
--------------------

Comparison Operators
~~~~~~~~~~~~~~~~~~~~

Build comparison expressions using standard C++ operators:

.. code-block:: cpp

   // Equality
   Student::age == 21           // Field equals value
   Student::name != "Unknown"   // Field not equals value

   // Relational
   Student::age < 25            // Less than
   Student::age <= 25           // Less than or equal
   Student::gpa > 3.5           // Greater than
   Student::gpa >= 3.5          // Greater than or equal

   // String operations work naturally
   Student::name == "Alice Johnson"
   Student::department != "Undeclared"

Logical Operators
~~~~~~~~~~~~~~~~~

Combine expressions using logical operators:

.. code-block:: cpp

   // AND
   (Student::age >= 18) && (Student::age <= 25)
   (Student::gpa >= 3.5) && (Student::department == "CS")

   // OR
   (Student::department == "CS") || (Student::department == "Math")
   (Student::age < 18) || (Student::age > 65)

   // Complex combinations
   ((Student::age >= 18) && (Student::gpa >= 3.0)) ||
   (Student::department == "Honors")

**Important:** Always parenthesize sub-expressions to ensure correct precedence!

.. code-block:: cpp

   // CORRECT
   auto expr = (Student::age >= 18) && (Student::gpa >= 3.0);

   // INCORRECT - may not compile or give wrong results
   auto expr = Student::age >= 18 && Student::gpa >= 3.0;  // Don't do this!

Table Query Methods
-------------------

where()
~~~~~~~

.. code-block:: cpp

   template<typename ExprType>
   auto where(const ExprType& expr);

Filters records using an expression template.

**Parameters:**

- ``expr`` - Expression built using Field objects and operators

**Returns:** Iterable range of matching records

**Example:**

.. code-block:: cpp

   // Simple comparison
   auto high_gpa = students.where(Student::gpa > 3.5);

   // Multiple conditions
   auto elite = students.where(
       (Student::department == "CS") && (Student::gpa >= 3.7)
   );

   // Iterate results (lazy evaluation)
   for (const auto& student : elite) {
       std::cout << student.get_name() << "\n";
   }

**Supported Operators:**

.. list-table::
   :header-rows: 1
   :widths: 20 40 40

   * - Operator
     - Example
     - Description
   * - ``==``
     - ``Field == value``
     - Equal to
   * - ``!=``
     - ``Field != value``
     - Not equal to
   * - ``<``
     - ``Field < value``
     - Less than
   * - ``<=``
     - ``Field <= value``
     - Less than or equal
   * - ``>``
     - ``Field > value``
     - Greater than
   * - ``>=``
     - ``Field >= value``
     - Greater than or equal
   * - ``&&``
     - ``expr1 && expr2``
     - Logical AND
   * - ``||``
     - ``expr1 || expr2``
     - Logical OR

find_if()
~~~~~~~~~

.. code-block:: cpp

   template<typename Predicate>
   auto find_if(Predicate pred);

Finds records matching a lambda predicate.

**Parameters:**

- ``pred`` - Lambda function taking ``const T&`` and returning ``bool``

**Returns:** Iterable range of matching records

**Example:**

.. code-block:: cpp

   auto filtered = students.find_if([](const Student& s) {
       return s.get_department() == "CS" && s.get_gpa() > 3.5;
   });

   for (const auto& student : filtered) {
       process(student);
   }

**When to use:**

- Complex logic not expressible with Field expressions
- Computed conditions
- Multi-field comparisons

find_by()
~~~~~~~~~

.. code-block:: cpp

   template<typename FieldType, typename ValueType>
   std::optional<T> find_by(
       const Field<T, FieldType>& field,
       const ValueType& value
   );

Finds a single record using a unique index. See :doc:`index` for details.

**Parameters:**

- ``field`` - Static Field object with unique index
- ``value`` - Value to search for

**Returns:** ``std::optional<T>`` containing record if found

**Example:**

.. code-block:: cpp

   // Requires unique index on name field
   auto student = students.find_by(Student::name, std::string("Alice"));

find_all_by()
~~~~~~~~~~~~~

.. code-block:: cpp

   template<typename FieldType, typename ValueType>
   std::vector<T> find_all_by(
       const Field<T, FieldType>& field,
       const ValueType& value
   );

Finds all records matching a value using a multi-value index. See :doc:`index` for details.

**Parameters:**

- ``field`` - Static Field object with multi-value index
- ``value`` - Value to search for

**Returns:** Vector of matching records

**Example:**

.. code-block:: cpp

   // Requires multi-value index on department field
   auto cs_students = students.find_all_by(
       Student::department,
       std::string("CS")
   );

range_query()
~~~~~~~~~~~~~

.. code-block:: cpp

   template<typename FieldType, typename ValueType>
   std::vector<T> range_query(
       const Field<T, FieldType>& field,
       const ValueType& min_value,
       const ValueType& max_value
   );

Finds all records with field values in range [min, max] (inclusive). Requires index on field.

**Parameters:**

- ``field`` - Static Field object with index
- ``min_value`` - Minimum value (inclusive)
- ``max_value`` - Maximum value (inclusive)

**Returns:** Vector of matching records

**Example:**

.. code-block:: cpp

   // Requires index on gpa field
   auto high_achievers = students.range_query(Student::gpa, 3.5, 4.0);

Join Operations
---------------

Join Class
~~~~~~~~~~

.. doxygenclass:: learnql::query::Join
   :members:

The ``Join`` class provides static methods for joining two tables.

inner_join()
~~~~~~~~~~~~

.. code-block:: cpp

   template<typename T1, typename T2, typename Key1Func, typename Key2Func>
   static auto inner_join(
       Table<T1>& table1,
       Table<T2>& table2,
       Key1Func key1_extractor,
       Key2Func key2_extractor
   );

Performs an inner join between two tables.

**Parameters:**

- ``table1`` - First table
- ``table2`` - Second table
- ``key1_extractor`` - Lambda extracting join key from T1
- ``key2_extractor`` - Lambda extracting join key from T2

**Returns:** Iterable of ``std::pair<T1, std::optional<T2>>``

**Example:**

.. code-block:: cpp

   auto student_enrollments = query::Join<Student, Enrollment>::inner_join(
       students,
       enrollments,
       [](const Student& s) { return s.get_student_id(); },
       [](const Enrollment& e) { return e.get_student_id(); }
   );

   for (const auto& [student, enrollment_opt] : student_enrollments) {
       if (enrollment_opt) {
           std::cout << student.get_name() << " enrolled in "
                     << enrollment_opt->get_course_code() << "\n";
       }
   }

left_join()
~~~~~~~~~~~

.. code-block:: cpp

   template<typename T1, typename T2, typename Key1Func, typename Key2Func>
   static auto left_join(
       Table<T1>& table1,
       Table<T2>& table2,
       Key1Func key1_extractor,
       Key2Func key2_extractor
   );

Performs a left join between two tables (includes all records from table1).

**Parameters:**

Same as ``inner_join()``

**Returns:** Iterable of ``std::pair<T1, std::optional<T2>>``

**Example:**

.. code-block:: cpp

   auto all_students = query::Join<Student, Enrollment>::left_join(
       students,
       enrollments,
       [](const Student& s) { return s.get_student_id(); },
       [](const Enrollment& e) { return e.get_student_id(); }
   );

   // Includes students with no enrollments (enrollment_opt will be nullopt)
   for (const auto& [student, enrollment_opt] : all_students) {
       std::cout << student.get_name();
       if (enrollment_opt) {
           std::cout << " - " << enrollment_opt->get_course_code();
       } else {
           std::cout << " - No enrollments";
       }
       std::cout << "\n";
   }

GroupBy Operations
------------------

GroupBy Class
~~~~~~~~~~~~~

.. doxygenclass:: learnql::query::GroupBy
   :members:

The ``GroupBy`` class provides static methods for grouping and aggregation.

count_by()
~~~~~~~~~~

.. code-block:: cpp

   template<typename T, typename KeyType, typename KeyFunc>
   static auto count_by(
       Table<T>& table,
       KeyFunc key_extractor
   );

Counts records grouped by a key.

**Parameters:**

- ``table`` - Table to group
- ``key_extractor`` - Lambda extracting group key from record

**Returns:** Vector of aggregation results with ``key`` and ``value`` (count)

**Example:**

.. code-block:: cpp

   auto dept_counts = query::GroupBy<Student, std::string>::count_by(
       students,
       [](const Student& s) { return s.get_department(); }
   );

   for (const auto& result : dept_counts) {
       std::cout << result.key << ": " << result.value << " students\n";
   }

average_by()
~~~~~~~~~~~~

.. code-block:: cpp

   template<typename T, typename KeyType, typename KeyFunc, typename ValueFunc>
   static auto average_by(
       Table<T>& table,
       KeyFunc key_extractor,
       ValueFunc value_extractor
   );

Computes average of a field grouped by a key.

**Parameters:**

- ``table`` - Table to group
- ``key_extractor`` - Lambda extracting group key
- ``value_extractor`` - Lambda extracting value to average

**Returns:** Vector of aggregation results with ``key``, ``value`` (average), and ``count``

**Example:**

.. code-block:: cpp

   auto dept_avg_gpa = query::GroupBy<Student, std::string>::average_by(
       students,
       [](const Student& s) { return s.get_department(); },
       [](const Student& s) { return s.get_gpa(); }
   );

   for (const auto& result : dept_avg_gpa) {
       std::cout << result.key << ": avg GPA = " << result.value
                 << " (" << result.count << " students)\n";
   }

Query Builder Pattern (Optional)
---------------------------------

Query Class
~~~~~~~~~~~

.. doxygenclass:: learnql::query::Query
   :members:

The ``Query`` class provides an optional builder pattern for constructing queries.

**Note:** Most users should use the simpler ``table.where()`` and ``table.find_if()`` methods. The Query builder is provided for advanced use cases.

**Template Parameters:**

- ``T`` - The record type
- ``BatchSize`` - Number of records to load per batch (default: 10)

Constructor
~~~~~~~~~~~

.. code-block:: cpp

   template<typename T, std::size_t BatchSize = 10>
   explicit Query(Table<T, BatchSize>& table);

**Example:**

.. code-block:: cpp

   query::Query<Student, 10> student_query(students);

Methods
~~~~~~~

count()
^^^^^^^

.. code-block:: cpp

   [[nodiscard]] std::size_t count() const;

Counts the number of records in the table.

**Example:**

.. code-block:: cpp

   query::Query<Student> q(students);
   std::cout << "Total: " << q.count() << "\n";

any()
^^^^^

.. code-block:: cpp

   [[nodiscard]] bool any() const;

Returns ``true`` if table has any records.

**Example:**

.. code-block:: cpp

   if (query::Query<Student>(students).any()) {
       std::cout << "Table has data\n";
   }

Usage Examples
--------------

Simple Filtering
~~~~~~~~~~~~~~~~

.. code-block:: cpp

   // Single condition
   auto adults = students.where(Student::age >= 18);

   // Multiple conditions with AND
   auto honors = students.where(
       (Student::gpa >= 3.5) && (Student::age >= 18)
   );

   // Multiple conditions with OR
   auto special = students.where(
       (Student::gpa >= 3.8) || (Student::age <= 16)
   );

All Comparison Operators
~~~~~~~~~~~~~~~~~~~~~~~~~

.. code-block:: cpp

   // Equal
   auto age_20 = students.where(Student::age == 20);

   // Not equal
   auto not_20 = students.where(Student::age != 20);

   // Less than
   auto young = students.where(Student::gpa < 3.5);

   // Greater or equal
   auto high_achievers = students.where(Student::gpa >= 3.9);

Complex Nested Expressions
~~~~~~~~~~~~~~~~~~~~~~~~~~~

.. code-block:: cpp

   // Scholarship eligibility:
   // (GPA >= 3.5 AND credits >= 60) OR (GPA >= 3.8 AND major == "Honors")
   auto eligible = students.where(
       ((Student::gpa >= 3.5) && (Student::credits >= 60)) ||
       ((Student::gpa >= 3.8) && (Student::major == "Honors"))
   );

Lambda Predicates
~~~~~~~~~~~~~~~~~

.. code-block:: cpp

   // Complex logic with lambda
   auto filtered = students.find_if([](const Student& s) {
       // Custom business logic
       return s.get_department() == "CS" &&
              s.get_gpa() > 3.5 &&
              s.get_age() >= 18 &&
              s.get_credits() >= 90;
   });

Join with Post-Processing
~~~~~~~~~~~~~~~~~~~~~~~~~~

.. code-block:: cpp

   auto& students = db.table<Student>("students");
   auto& enrollments = db.table<Enrollment>("enrollments");

   auto student_enrollments = query::Join<Student, Enrollment>::inner_join(
       students,
       enrollments,
       [](const Student& s) { return s.get_student_id(); },
       [](const Enrollment& e) { return e.get_student_id(); }
   );

   // Process joined results
   for (const auto& [student, enrollment_opt] : student_enrollments) {
       if (enrollment_opt) {
           std::cout << student.get_name() << " -> "
                     << enrollment_opt->get_course_code()
                     << " (Grade: " << enrollment_opt->get_grade() << ")\n";
       }
   }

Multi-Table Aggregation
~~~~~~~~~~~~~~~~~~~~~~~~

.. code-block:: cpp

   // Join students -> enrollments -> courses
   auto student_course_join = query::Join<Student, Enrollment>::inner_join(
       students,
       enrollments,
       [](const Student& s) { return s.get_student_id(); },
       [](const Enrollment& e) { return e.get_student_id(); }
   );

   // Calculate total credits per student
   std::unordered_map<int, int> student_credits;
   for (const auto& [student, enrollment_opt] : student_course_join) {
       if (enrollment_opt) {
           auto course = courses.find(enrollment_opt->get_course_code());
           if (course) {
               student_credits[student.get_student_id()] += course->get_credits();
           }
       }
   }

Combining with Ranges
~~~~~~~~~~~~~~~~~~~~~

.. code-block:: cpp

   #include <ranges>

   // Query + ranges pipeline
   auto top_performers = students.where(Student::age >= 18)
       | std::views::transform([](auto& s) {
           return std::pair{s.get_name(), s.get_gpa()};
         })
       | std::views::take(10);

   for (const auto& [name, gpa] : top_performers) {
       std::cout << name << ": " << gpa << "\n";
   }

Performance Considerations
--------------------------

Expression Template Overhead
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Expression templates are resolved at compile-time, resulting in **zero runtime overhead**:

.. code-block:: cpp

   // These are equivalent at runtime:

   // Expression template version
   auto results1 = students.where(Student::age >= 18);

   // Lambda version
   auto results2 = students.find_if([](const Student& s) {
       return s.get_age() >= 18;
   });

Batched Iteration
~~~~~~~~~~~~~~~~~

Results are loaded in batches to minimize memory usage:

.. code-block:: cpp

   // Lazy evaluation - loads batches on demand
   auto results = students.where(Student::age >= 18);

   // Only current batch in memory
   for (const auto& student : results) {
       process(student);  // Batch loaded automatically
   }

Index Usage
~~~~~~~~~~~

Queries automatically use indexes when available:

.. code-block:: cpp

   // Create index
   students.add_index(Student::age, core::IndexType::MultiValue);

   // This query uses the index (O(log n) instead of O(n))
   auto adults = students.where(Student::age >= 18);

Best Practices
--------------

1. **Always Parenthesize Logical Expressions**

   .. code-block:: cpp

      // GOOD
      auto expr = (Student::age >= 18) && (Student::gpa >= 3.0);

      // BAD - may cause compilation errors
      auto expr = Student::age >= 18 && Student::gpa >= 3.0;

2. **Use Expression Templates When Possible**

   .. code-block:: cpp

      // PREFERRED - more readable, type-safe
      auto results = students.where(Student::age >= 18);

      // Use lambda only when necessary
      auto results = students.find_if([](const Student& s) {
          return complex_logic(s);
      });

3. **Leverage Lazy Evaluation**

   .. code-block:: cpp

      // GOOD - processes results as they're loaded
      for (const auto& student : students.where(Student::gpa > 3.5)) {
          process(student);
      }

4. **Create Indexes for Frequent Queries**

   .. code-block:: cpp

      // If you frequently query by department
      students.add_index(Student::department, core::IndexType::MultiValue);

      // Future queries are much faster
      auto cs_students = students.find_all_by(Student::department, "CS");

5. **Use Appropriate Join Type**

   .. code-block:: cpp

      // INNER JOIN - only matching records
      auto matches = query::Join<T1, T2>::inner_join(...);

      // LEFT JOIN - all records from first table
      auto all = query::Join<T1, T2>::left_join(...);

Troubleshooting
---------------

Compilation Errors with Expressions
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

**Problem:** Complex expressions fail to compile

**Solution:** Add parentheses around sub-expressions

.. code-block:: cpp

   // ERROR
   auto expr = Student::age >= 18 && Student::gpa >= 3.0;

   // FIXED
   auto expr = (Student::age >= 18) && (Student::gpa >= 3.0);

Field Type Mismatch
~~~~~~~~~~~~~~~~~~~

**Problem:** Comparing field with wrong type

**Solution:** Ensure comparison value matches field type

.. code-block:: cpp

   // ERROR - comparing int field with string
   auto expr = Student::age == "18";

   // FIXED
   auto expr = Student::age == 18;

Missing Static Field
~~~~~~~~~~~~~~~~~~~~

**Problem:** ``Student::age`` not found

**Cause:** Field not declared in ``LEARNQL_PROPERTIES_BEGIN``

**Solution:** Ensure all fields are declared with ``LEARNQL_PROPERTY``

.. code-block:: cpp

   LEARNQL_PROPERTIES_BEGIN(Student)
       LEARNQL_PROPERTY(int, student_id, PK)
       LEARNQL_PROPERTY(int, age)  // ‚Üê Must be declared
   LEARNQL_PROPERTIES_END(...)

See Also
--------

- :doc:`core` - Table and Database classes
- :doc:`index` - Index operations (find_by, find_all_by, range_query)
- :doc:`ranges` - C++20 ranges integration
- :doc:`reflection` - LEARNQL_PROPERTIES macro system
- :doc:`../tutorials/querying` - Tutorial on building queries
- :doc:`../guides/performance` - Performance tuning guide

**Related Classes:**

- ``Table<T>`` - Table container providing query methods
- ``Field<T, FieldType>`` - Static field descriptor
- ``Database`` - Database management
