Reflection Module
=================

.. contents:: Table of Contents
   :local:
   :depth: 2

Overview
--------

The Reflection module provides compile-time introspection capabilities for C++ structs and classes. It enables LearnQL to automatically discover field names, types, and metadata without relying on runtime reflection or external code generation tools. This is achieved through C++ template metaprogramming and macros.

**Key Features:**

- Compile-time field discovery (zero runtime overhead)
- Automatic metadata extraction for catalog
- Type-safe field access
- Property descriptor generation
- Integration with query expressions

**Module Components:**

- ``LEARNQL_PROPERTIES_*`` macros - Define reflectable properties
- ``FieldInfo`` - Field metadata structure
- ``FieldExtractor`` - Metadata extraction utilities
- ``Reflectable`` concept - Compile-time validation

Quick Start
-----------

Making a Class Reflectable
~~~~~~~~~~~~~~~~~~~~~~~~~~~

.. code-block:: cpp

   #include <learnql/meta/Property.hpp>

   class Student {
   public:
       // Define properties using macros
       LEARNQL_PROPERTIES_BEGIN(Student)
           LEARNQL_PROPERTY(int, id, PK)           // Primary key
           LEARNQL_PROPERTY(std::string, name)      // Regular field
           LEARNQL_PROPERTY(int, age)
           LEARNQL_PROPERTY(double, gpa)
       LEARNQL_PROPERTIES_END(
           PROP(int, id, PK),
           PROP(std::string, name),
           PROP(int, age),
           PROP(double, gpa)
       )

   private:
       int id_;
       std::string name_;
       int age_;
       double gpa_;
   };

Using Reflection
~~~~~~~~~~~~~~~~

.. code-block:: cpp

   #include <learnql/reflection/FieldExtractor.hpp>

   // Extract field metadata
   auto fields = reflection::extract_field_metadata<Student>("students");

   // Iterate over fields
   for (const auto& field : fields) {
       std::cout << field.field_name << " (" << field.field_type << ")\n";
   }

   // Output:
   // id (int) PK
   // name (std::string)
   // age (int)
   // gpa (double)

Property Descriptors
~~~~~~~~~~~~~~~~~~~~

Property descriptors enable type-safe queries:

.. code-block:: cpp

   // Query using property descriptors (generated by macros)
   auto adults = students.where(Student::age >= 18);
   auto top_students = students.where(Student::gpa > 3.5);

Core Concepts
-------------

Property System
~~~~~~~~~~~~~~~

LearnQL uses **property descriptors** to enable compile-time reflection:

.. code-block:: text

   C++ Struct/Class
         ↓
   LEARNQL_PROPERTIES_* macros
         ↓
   Property Descriptors (static members)
         ↓
   Queryable Fields + Type Information

**Benefits:**

- Type safety - catch errors at compile time
- Zero runtime overhead - all resolved at compile time
- IntelliSense support - IDE autocompletion works
- No external tools required - pure C++ solution

Property Descriptors
~~~~~~~~~~~~~~~~~~~~

Each field gets a static property descriptor:

.. code-block:: cpp

   class Student {
   public:
       // These are generated by LEARNQL_PROPERTIES_* macros
       static inline Property<Student, int> id;
       static inline Property<Student, std::string> name;
       static inline Property<Student, int> age;
       static inline Property<Student, double> gpa;

       // Getters/setters
       int get_id() const { return id_; }
       void set_id(int value) { id_ = value; }
       // ...
   };

   // Usage in queries
   auto expr = Student::age > 18;  // Type-safe expression!

Macro Reference
---------------

LEARNQL_PROPERTIES_BEGIN
~~~~~~~~~~~~~~~~~~~~~~~~

.. code-block:: cpp

   LEARNQL_PROPERTIES_BEGIN(ClassName)

Starts the property definition block for a class.

**Parameters:**

- ``ClassName`` - Name of the class being annotated

**Must be followed by:** One or more ``LEARNQL_PROPERTY`` declarations

LEARNQL_PROPERTY
~~~~~~~~~~~~~~~~

.. code-block:: cpp

   LEARNQL_PROPERTY(Type, name)
   LEARNQL_PROPERTY(Type, name, PK)  // For primary keys

Declares a reflectable property with getter/setter methods.

**Parameters:**

- ``Type`` - C++ type of the property
- ``name`` - Property name (generates ``get_name()`` / ``set_name()`` methods)
- ``PK`` (optional) - Mark as primary key

**Generates:**

.. code-block:: cpp

   // For: LEARNQL_PROPERTY(int, age)
   // Generates:

   private:
       int age_;

   public:
       int get_age() const { return age_; }
       void set_age(int value) { age_ = value; }

       static inline Property<ClassName, int> age{
           "age", &ClassName::get_age, &ClassName::set_age
       };

LEARNQL_PROPERTIES_END
~~~~~~~~~~~~~~~~~~~~~~

.. code-block:: cpp

   LEARNQL_PROPERTIES_END(
       PROP(Type1, name1),
       PROP(Type2, name2, PK),
       ...
   )

Ends the property definition block and generates reflection metadata.

**Parameters:**

- List of ``PROP(Type, name)`` or ``PROP(Type, name, PK)`` entries

**Generates:**

.. code-block:: cpp

   static std::vector<FieldInfo> reflect_fields() {
       return {
           FieldInfo{"name1", "Type1", 0, false},
           FieldInfo{"name2", "Type2", 1, true},  // is_primary_key = true
           ...
       };
   }

PROP Macro
~~~~~~~~~~

.. code-block:: cpp

   PROP(Type, name)
   PROP(Type, name, PK)

Used inside ``LEARNQL_PROPERTIES_END`` to list properties for reflection.

**Parameters:**

- ``Type`` - Property type
- ``name`` - Property name
- ``PK`` (optional) - Mark as primary key

Class Reference
---------------

FieldInfo Structure
~~~~~~~~~~~~~~~~~~~

.. doxygenstruct:: learnql::reflection::FieldInfo
   :members:

Stores metadata about a single field.

**Fields:**

.. code-block:: cpp

   struct FieldInfo {
       std::string name;           // Field name
       std::string type;           // C++ type name (e.g., "int", "std::string")
       std::size_t order;          // Position in struct (0-based)
       bool is_primary_key;        // true if marked with PK
   };

**Example:**

.. code-block:: cpp

   FieldInfo field{
       .name = "age",
       .type = "int",
       .order = 2,
       .is_primary_key = false
   };

Reflectable Concept
~~~~~~~~~~~~~~~~~~~

.. code-block:: cpp

   template<typename T>
   concept Reflectable = requires {
       { T::reflect_fields() };
   };

A type is ``Reflectable`` if it has a static ``reflect_fields()`` method that returns field metadata.

**Usage:**

.. code-block:: cpp

   template<Reflectable T>
   void process(T& obj) {
       auto fields = T::reflect_fields();
       // ...
   }

   // Compile-time check
   static_assert(Reflectable<Student>, "Student must be reflectable");

FieldExtractor Functions
~~~~~~~~~~~~~~~~~~~~~~~~~

``extract_field_metadata()``
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. code-block:: cpp

   template<typename T>
   std::vector<catalog::FieldMetadata> extract_field_metadata(
       const std::string& table_name,
       uint64_t start_id = 1
   );

Extracts ``FieldMetadata`` records for catalog registration.

**Parameters:**

- ``table_name`` - Name of the table
- ``start_id`` - Starting field ID (default: 1)

**Returns:** Vector of ``FieldMetadata`` records

**Example:**

.. code-block:: cpp

   auto fields = reflection::extract_field_metadata<Student>("students", 1);

   // fields[0] = {id: 1, table: "students", name: "id", type: "int", is_pk: true}
   // fields[1] = {id: 2, table: "students", name: "name", type: "std::string", is_pk: false}
   // ...

``is_reflectable()``
^^^^^^^^^^^^^^^^^^^^

.. code-block:: cpp

   template<typename T>
   constexpr bool is_reflectable();

Checks if a type supports reflection at compile-time.

**Returns:** ``true`` if ``T`` is ``Reflectable``

**Example:**

.. code-block:: cpp

   if constexpr (is_reflectable<Student>()) {
       // Safe to call reflect_fields()
   }

``field_count()``
^^^^^^^^^^^^^^^^^

.. code-block:: cpp

   template<Reflectable T>
   std::size_t field_count();

Returns the number of fields in a reflectable type.

**Returns:** Number of fields

**Example:**

.. code-block:: cpp

   std::cout << "Student has " << field_count<Student>() << " fields\n";

Usage Examples
--------------

Basic Class with Reflection
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

.. code-block:: cpp

   class Product {
   public:
       LEARNQL_PROPERTIES_BEGIN(Product)
           LEARNQL_PROPERTY(int, id, PK)
           LEARNQL_PROPERTY(std::string, name)
           LEARNQL_PROPERTY(double, price)
           LEARNQL_PROPERTY(int, stock)
       LEARNQL_PROPERTIES_END(
           PROP(int, id, PK),
           PROP(std::string, name),
           PROP(double, price),
           PROP(int, stock)
       )
   };

   // Use in queries
   Table<Product> products;
   auto expensive = products.where(Product::price > 100.0);
   auto low_stock = products.where(Product::stock < 10);

Nested Structures
~~~~~~~~~~~~~~~~~

.. code-block:: cpp

   // You can use complex types as field types
   class Address {
   public:
       std::string street;
       std::string city;
       std::string zip;
   };

   class Customer {
   public:
       LEARNQL_PROPERTIES_BEGIN(Customer)
           LEARNQL_PROPERTY(int, id, PK)
           LEARNQL_PROPERTY(std::string, name)
           LEARNQL_PROPERTY(Address, address)  // Complex type
       LEARNQL_PROPERTIES_END(
           PROP(int, id, PK),
           PROP(std::string, name),
           PROP(Address, address)
       )
   };

   // Note: Address must be serializable
   // (provide serialize/deserialize methods)

Iterating Over Fields
~~~~~~~~~~~~~~~~~~~~~

.. code-block:: cpp

   void print_field_info() {
       auto fields = Student::reflect_fields();

       std::cout << "Student fields:\n";
       for (const auto& field : fields) {
           std::cout << "  " << field.name
                     << " (" << field.type << ")";

           if (field.is_primary_key) {
               std::cout << " [PRIMARY KEY]";
           }

           std::cout << "\n";
       }
   }

   // Output:
   // Student fields:
   //   id (int) [PRIMARY KEY]
   //   name (std::string)
   //   age (int)
   //   gpa (double)

Dynamic Schema Discovery
~~~~~~~~~~~~~~~~~~~~~~~~

.. code-block:: cpp

   template<Reflectable T>
   void describe_type(const std::string& type_name) {
       auto fields = T::reflect_fields();

       std::cout << "Type: " << type_name << "\n";
       std::cout << "Fields: " << fields.size() << "\n\n";

       for (const auto& field : fields) {
           std::cout << "  " << field.order << ". "
                     << field.name << ": " << field.type;

           if (field.is_primary_key) {
               std::cout << " (PK)";
           }

           std::cout << "\n";
       }
   }

   // Usage
   describe_type<Student>("Student");
   describe_type<Product>("Product");

Generating SQL DDL (Educational)
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

.. code-block:: cpp

   template<Reflectable T>
   std::string generate_create_table_sql(const std::string& table_name) {
       std::ostringstream sql;
       sql << "CREATE TABLE " << table_name << " (\n";

       auto fields = T::reflect_fields();
       for (std::size_t i = 0; i < fields.size(); ++i) {
           const auto& field = fields[i];

           sql << "  " << field.name << " ";

           // Map C++ types to SQL types
           if (field.type == "int") {
               sql << "INTEGER";
           } else if (field.type == "std::string") {
               sql << "TEXT";
           } else if (field.type == "double") {
               sql << "REAL";
           } else {
               sql << "BLOB";  // Unknown types
           }

           if (field.is_primary_key) {
               sql << " PRIMARY KEY";
           }

           if (i < fields.size() - 1) {
               sql << ",";
           }

           sql << "\n";
       }

       sql << ");";
       return sql.str();
   }

   // Usage
   std::cout << generate_create_table_sql<Student>("students");

   // Output:
   // CREATE TABLE students (
   //   id INTEGER PRIMARY KEY,
   //   name TEXT,
   //   age INTEGER,
   //   gpa REAL
   // );

Validation
~~~~~~~~~~

.. code-block:: cpp

   // Ensure type has at least one field
   template<typename T>
   void validate_type() {
       static_assert(Reflectable<T>, "Type must be reflectable");

       auto fields = T::reflect_fields();
       if (fields.empty()) {
           throw std::runtime_error("Type has no fields");
       }

       // Ensure type has exactly one primary key
       std::size_t pk_count = std::count_if(
           fields.begin(), fields.end(),
           [](auto& f) { return f.is_primary_key; }
       );

       if (pk_count == 0) {
           throw std::runtime_error("Type has no primary key");
       }

       if (pk_count > 1) {
           throw std::runtime_error("Type has multiple primary keys");
       }
   }

   // Validate at compile-time or runtime
   validate_type<Student>();

Advanced Patterns
-----------------

Type Mapping
~~~~~~~~~~~~

Map C++ types to human-readable names:

.. code-block:: cpp

   template<typename T>
   constexpr const char* type_name() {
       if constexpr (std::is_same_v<T, int>) return "Integer";
       else if constexpr (std::is_same_v<T, double>) return "Float";
       else if constexpr (std::is_same_v<T, std::string>) return "String";
       else return "Unknown";
   }

   void print_readable_schema() {
       auto fields = Student::reflect_fields();

       for (const auto& field : fields) {
           std::cout << field.name << ": ";

           if (field.type == "int") {
               std::cout << type_name<int>();
           } else if (field.type == "double") {
               std::cout << type_name<double>();
           } else if (field.type == "std::string") {
               std::cout << type_name<std::string>();
           }

           std::cout << "\n";
       }
   }

Generic Field Access
~~~~~~~~~~~~~~~~~~~~

While LearnQL's reflection is primarily for metadata, you can combine it with property descriptors for generic access:

.. code-block:: cpp

   template<Reflectable T>
   void print_record(const T& record) {
       auto fields = T::reflect_fields();

       for (const auto& field : fields) {
           std::cout << field.name << ": ";

           // Use property descriptors to get values
           // (This requires additional metaprogramming - see Property.hpp)
           if (field.name == "id") {
               std::cout << T::id.get(record);
           } else if (field.name == "name") {
               std::cout << T::name.get(record);
           }
           // ... (or use a dispatch table)

           std::cout << "\n";
       }
   }

Limitations
-----------

Current Limitations
~~~~~~~~~~~~~~~~~~~

1. **No Arbitrary Getter/Setter Names**

   .. code-block:: cpp

      // Currently, getters MUST be named get_<field>()
      LEARNQL_PROPERTY(int, age)  // Generates get_age() / set_age()

      // You can't use custom names like:
      // int getAge()  // Won't work
      // int Age()     // Won't work

2. **No Method Reflection**

   Only data members (properties) are reflected, not methods.

3. **No Inheritance Reflection**

   Base class fields are not automatically reflected.

   .. code-block:: cpp

      class Base {
      public:
          LEARNQL_PROPERTIES_BEGIN(Base)
              LEARNQL_PROPERTY(int, base_id)
          LEARNQL_PROPERTIES_END(PROP(int, base_id))
      };

      class Derived : public Base {
      public:
          LEARNQL_PROPERTIES_BEGIN(Derived)
              LEARNQL_PROPERTY(int, derived_id)
          LEARNQL_PROPERTIES_END(PROP(int, derived_id))
          // base_id is NOT automatically included
      };

4. **Manual Duplication**

   Property list must be specified twice (in BEGIN/END sections):

   .. code-block:: cpp

      LEARNQL_PROPERTIES_BEGIN(Student)
          LEARNQL_PROPERTY(int, id, PK)      // First time
          LEARNQL_PROPERTY(std::string, name)
      LEARNQL_PROPERTIES_END(
          PROP(int, id, PK),                  // Second time (duplicated)
          PROP(std::string, name)
      )

   This is due to C++ macro limitations and could be improved with future C++ reflection features.

Comparison to Other Approaches
-------------------------------

LearnQL vs. External Code Generators
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

.. list-table::
   :header-rows: 1
   :widths: 30 35 35

   * - Feature
     - LearnQL (Macros)
     - External Tools
   * - Setup
     - Zero - just include headers
     - Requires build integration
   * - IDE Support
     - Full IntelliSense
     - May need plugins
   * - Compile Time
     - Minimal increase
     - Can slow builds
   * - Type Safety
     - Compile-time
     - Compile-time
   * - Flexibility
     - Limited by macros
     - Highly customizable

LearnQL vs. Runtime Reflection
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

.. list-table::
   :header-rows: 1
   :widths: 30 35 35

   * - Feature
     - LearnQL (Compile-time)
     - Runtime Reflection
   * - Performance
     - Zero overhead
     - Runtime cost
   * - Type Information
     - Compile-time only
     - Available at runtime
   * - Binary Size
     - Minimal
     - Larger (metadata)
   * - Flexibility
     - Limited
     - Very flexible

Future C++ Reflection
~~~~~~~~~~~~~~~~~~~~~

C++26 may include built-in reflection (P2996), which would enable:

.. code-block:: cpp

   // Hypothetical C++26 code
   template<typename T>
   void print_fields() {
       constexpr auto fields = std::meta::members_of(^T);

       [:fields:] >> [](auto field) {
           std::cout << std::meta::name_of(field) << "\n";
       };
   }

LearnQL's macro-based approach is a pragmatic solution until native reflection arrives.

Best Practices
--------------

1. **Always Use PK for Primary Keys**

   .. code-block:: cpp

      // GOOD
      LEARNQL_PROPERTY(int, id, PK)

      // BAD - no primary key marked
      LEARNQL_PROPERTY(int, id)

2. **Keep Property Names Consistent**

   .. code-block:: cpp

      // GOOD - property name matches member variable
      private:
          int age_;

      public:
          LEARNQL_PROPERTY(int, age)  // Consistent

3. **Order Properties Logically**

   .. code-block:: cpp

      // GOOD - primary key first, then logical grouping
      LEARNQL_PROPERTIES_BEGIN(Student)
          LEARNQL_PROPERTY(int, id, PK)
          LEARNQL_PROPERTY(std::string, first_name)
          LEARNQL_PROPERTY(std::string, last_name)
          LEARNQL_PROPERTY(int, age)
          LEARNQL_PROPERTY(double, gpa)
      LEARNQL_PROPERTIES_END(...)

4. **Document Complex Types**

   .. code-block:: cpp

      class Student {
      public:
          LEARNQL_PROPERTIES_BEGIN(Student)
              LEARNQL_PROPERTY(int, id, PK)
              LEARNQL_PROPERTY(std::string, name)

              // Complex type - ensure it's serializable
              LEARNQL_PROPERTY(Transcript, transcript)  ///< Student transcript
          LEARNQL_PROPERTIES_END(...)
      };

5. **Validate at Compile Time When Possible**

   .. code-block:: cpp

      static_assert(Reflectable<Student>, "Student must be reflectable");
      static_assert(field_count<Student>() > 0, "Student must have fields");

Troubleshooting
---------------

Macro Expansion Errors
~~~~~~~~~~~~~~~~~~~~~~

**Problem:** Cryptic compiler errors about macros

**Cause:** Missing comma or parenthesis in property list

**Solution:** Carefully check syntax

.. code-block:: cpp

   // WRONG - missing comma
   LEARNQL_PROPERTIES_END(
       PROP(int, id, PK)
       PROP(std::string, name)  // ← Missing comma!
   )

   // CORRECT
   LEARNQL_PROPERTIES_END(
       PROP(int, id, PK),
       PROP(std::string, name)
   )

Type Not Reflectable
~~~~~~~~~~~~~~~~~~~~

**Problem:** ``static_assert(Reflectable<T>)`` fails

**Cause:** Missing ``LEARNQL_PROPERTIES_*`` macros

**Solution:** Add property macros to the class

.. code-block:: cpp

   // WRONG - no reflection
   class Student {
       int id_;
       std::string name_;
   };

   // CORRECT - with reflection
   class Student {
   public:
       LEARNQL_PROPERTIES_BEGIN(Student)
           LEARNQL_PROPERTY(int, id, PK)
           LEARNQL_PROPERTY(std::string, name)
       LEARNQL_PROPERTIES_END(
           PROP(int, id, PK),
           PROP(std::string, name)
       )
   };

Property Descriptor Not Found
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

**Problem:** ``Student::age`` not found in queries

**Cause:** Property not declared in ``LEARNQL_PROPERTIES_BEGIN``

**Solution:** Ensure all properties are declared

.. code-block:: cpp

   // Add the missing property
   LEARNQL_PROPERTIES_BEGIN(Student)
       LEARNQL_PROPERTY(int, id, PK)
       LEARNQL_PROPERTY(std::string, name)
       LEARNQL_PROPERTY(int, age)  // ← Add this
   LEARNQL_PROPERTIES_END(...)

See Also
--------

- :doc:`catalog` - Uses reflection for metadata generation
- :doc:`query` - Uses property descriptors in queries
- :doc:`serialization` - Serialization requires reflectable types
- :doc:`../tutorials/schema` - Schema design with reflection
- :doc:`../guides/architecture` - Overall architecture

**Related Headers:**

- ``learnql/meta/Property.hpp`` - Property descriptor implementation
- ``learnql/reflection/FieldInfo.hpp`` - Field metadata structure
- ``learnql/reflection/FieldExtractor.hpp`` - Metadata extraction utilities
