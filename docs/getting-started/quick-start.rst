Quick Start
===========

This guide will get you up and running with LearnQL in 30 minutes. You'll learn how to create a database, define tables, insert data, and perform queries.

Prerequisites
-------------

* C++20 compatible compiler (GCC 10+, Clang 12+, or MSVC 19.29+)
* LearnQL installed (see :doc:`installation`)
* Basic understanding of C++ and SQL concepts

Your First Database
-------------------

Let's create a simple student management system.

Step 1: Define Your Data Models
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

First, define C++ classes to represent your data using the ``LEARNQL_PROPERTIES`` macro system:

.. code-block:: cpp

   #include <learnql/LearnQL.hpp>
   #include <iostream>

   using namespace learnql;

   // Define a Student class
   class Student {
       LEARNQL_PROPERTIES_BEGIN(Student)
           LEARNQL_PROPERTY(int, student_id, PK)
           LEARNQL_PROPERTY(std::string, name)
           LEARNQL_PROPERTY(int, age)
           LEARNQL_PROPERTY(std::string, major)
       LEARNQL_PROPERTIES_END(
           PROP(int, student_id, PK),
           PROP(std::string, name),
           PROP(int, age),
           PROP(std::string, major)
       )

   public:
       Student() = default;

       // Convenience constructor
       Student(int id, const std::string& n, int a, const std::string& m)
           : student_id_(id), name_(n), age_(a), major_(m) {}
   };

.. note::
   The ``LEARNQL_PROPERTIES`` system automatically generates private member variables (with trailing underscore), type-safe getters and setters, static Field objects for queries, and serialization support. The ``PK`` marker indicates the primary key. This reduces boilerplate by ~70%!

Step 2: Create a Database
~~~~~~~~~~~~~~~~~~~~~~~~~~

Create a database instance and a table:

.. code-block:: cpp

   int main() {
       // Create a database (file will be created if it doesn't exist)
       core::Database db("university.db");

       // Get a type-safe table reference
       auto& students = db.table<Student>("students");

       std::cout << "Database and table created successfully!" << std::endl;
   }

You can also use an in-memory database for testing:

.. code-block:: cpp

   core::Database db(":memory:");  // Data won't persist

Step 3: Insert Data
~~~~~~~~~~~~~~~~~~~

Insert records using the convenience constructor:

.. code-block:: cpp

   // Insert individual students
   students.insert(Student(1, "Alice Johnson", 20, "Computer Science"));
   students.insert(Student(2, "Bob Smith", 22, "Mathematics"));
   students.insert(Student(3, "Carol White", 19, "Physics"));
   students.insert(Student(4, "David Brown", 21, "Computer Science"));

   std::cout << "Inserted 4 students" << std::endl;

.. tip::
   LearnQL automatically manages primary keys (the field marked with ``PK``). Records are indexed using a B-tree for efficient lookups.

Step 4: Query Data
~~~~~~~~~~~~~~~~~~

Use the type-safe query DSL with static Field objects to retrieve data:

Basic Iteration
^^^^^^^^^^^^^^^

.. code-block:: cpp

   // Iterate over all students
   for (const auto& student : students) {
       std::cout << student.get_name() << " (" << student.get_age() << ")" << std::endl;
   }

.. note::
   Properties use getter methods: ``get_name()``, ``get_age()``, etc. LearnQL generates these automatically!

Filtering with ``where``
^^^^^^^^^^^^^^^^^^^^^^^^^

Use static Field objects to build type-safe predicates:

.. code-block:: cpp

   // Find students 21 or older
   auto adults = students.where(Student::age >= 21);

   for (const auto& student : adults) {
       std::cout << student.get_name() << " (" << student.get_age() << ")" << std::endl;
   }

   // Find Computer Science majors
   auto cs_students = students.where(Student::major == "Computer Science");

   for (const auto& student : cs_students) {
       std::cout << student.get_name() << std::endl;
   }

   // Complex conditions with && (AND) and || (OR)
   auto young_cs = students.where(
       (Student::major == "Computer Science") && (Student::age < 21)
   );

.. note::
   ``where()`` returns an iterable range directly - no need to call ``.execute()``! The static Field objects (like ``Student::age``) are automatically generated by the ``LEARNQL_PROPERTIES`` system.

Using ``find_if`` with Lambda Predicates
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

For complex filtering logic:

.. code-block:: cpp

   // Find students using a custom predicate
   auto filtered = students.find_if([](const Student& s) {
       return s.get_age() >= 21 && s.get_major() == "Computer Science";
   });

   for (const auto& student : filtered) {
       std::cout << student.get_name() << std::endl;
   }

Step 5: Update Records
~~~~~~~~~~~~~~~~~~~~~~

Find and modify records using the new fluent API:

.. code-block:: cpp

   // Find a student by ID (returns std::optional<Student>)
   auto alice = students.find(1);

   if (alice) {
       // Update the age using setter
       alice->set_age(21);
       students.update(*alice);

       std::cout << "Updated student age" << std::endl;
   }

.. important::
   ``find()`` returns ``std::optional<Student>`` directly, not a RecordId! Use setters like ``set_age()`` to modify values.

Step 6: Delete Records
~~~~~~~~~~~~~~~~~~~~~~

.. code-block:: cpp

   // Delete a specific student by primary key
   if (students.contains(2)) {
       students.remove(2);
       std::cout << "Deleted student" << std::endl;
   }

Complete Example
----------------

Here's a complete working program:

.. code-block:: cpp

   #include <learnql/LearnQL.hpp>
   #include <iostream>

   using namespace learnql;

   class Student {
       LEARNQL_PROPERTIES_BEGIN(Student)
           LEARNQL_PROPERTY(int, student_id, PK)
           LEARNQL_PROPERTY(std::string, name)
           LEARNQL_PROPERTY(int, age)
           LEARNQL_PROPERTY(std::string, major)
       LEARNQL_PROPERTIES_END(
           PROP(int, student_id, PK),
           PROP(std::string, name),
           PROP(int, age),
           PROP(std::string, major)
       )

   public:
       Student() = default;

       Student(int id, const std::string& n, int a, const std::string& m)
           : student_id_(id), name_(n), age_(a), major_(m) {}
   };

   int main() {
       // Create database
       core::Database db("university.db");
       auto& students = db.table<Student>("students");

       // Insert data
       students.insert(Student(1, "Alice Johnson", 20, "Computer Science"));
       students.insert(Student(2, "Bob Smith", 22, "Mathematics"));
       students.insert(Student(3, "Carol White", 19, "Physics"));
       students.insert(Student(4, "David Brown", 21, "Computer Science"));

       // Query: Find CS majors aged 21+
       std::cout << "Computer Science students (age 21+):" << std::endl;

       auto cs_adults = students.where(
           (Student::major == "Computer Science") && (Student::age >= 21)
       );

       for (const auto& student : cs_adults) {
           std::cout << "  - " << student.get_name()
                     << " (age " << student.get_age() << ")" << std::endl;
       }

       // Count total students
       std::cout << "\nTotal students: " << students.size() << std::endl;

       return 0;
   }

Compile and run:

.. code-block:: bash

   g++ -std=c++20 -o university main.cpp
   ./university

Expected output:

.. code-block:: text

   Computer Science students (age 21+):
     - David Brown (age 21)

   Total students: 4

Key Concepts Learned
--------------------

✅ **Property Macros**: Use ``LEARNQL_PROPERTIES_BEGIN/END`` to define database-aware classes with automatic getter/setter generation

✅ **Type Safety**: Static Field objects (``Student::age``) provide compile-time type checking

✅ **Direct Iteration**: ``where()`` and ``find_if()`` return iterable ranges - no ``.execute()`` needed

✅ **CRUD Operations**: ``insert()``, ``find()``, ``update()``, ``remove()``

✅ **Persistence**: Data is automatically saved to disk (unless using ``:memory:``)

Common Patterns
---------------

Check if Record Exists
~~~~~~~~~~~~~~~~~~~~~~

.. code-block:: cpp

   if (students.contains(123)) {
       std::cout << "Student exists!" << std::endl;
   } else {
       std::cout << "Student not found" << std::endl;
   }

Find by Primary Key
~~~~~~~~~~~~~~~~~~~

.. code-block:: cpp

   auto student = students.find(123);
   if (student) {
       std::cout << "Found: " << student->get_name() << std::endl;
   } else {
       std::cout << "Student not found" << std::endl;
   }

Iterate All Records
~~~~~~~~~~~~~~~~~~~

.. code-block:: cpp

   for (const auto& student : students) {
       std::cout << student.get_name() << std::endl;
   }

Count Records Matching Condition
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

.. code-block:: cpp

   int count = 0;
   for (const auto& student : students.where(Student::major == "Computer Science")) {
       count++;
   }
   std::cout << "CS majors: " << count << std::endl;

In-Memory Databases for Testing
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

.. code-block:: cpp

   core::Database db(":memory:");  // Fast, no disk I/O
   // Perfect for unit tests!

What's Next?
------------

Now that you've mastered the basics, explore:

* :doc:`core-concepts` - Deep dive into LearnQL's architecture
* :doc:`property-macros` - Advanced property macro techniques
* :doc:`/tutorials/tutorial-03-query-dsl` - Master the query DSL
* :doc:`/tutorials/tutorial-04-joins-relationships` - Work with related data
* :doc:`/tutorials/tutorial-06-indexes-performance` - Optimize performance with secondary indexes

.. tip::
   The ``main.cpp`` file in the LearnQL repository contains a comprehensive example with all features demonstrated. Check it out for more inspiration!
