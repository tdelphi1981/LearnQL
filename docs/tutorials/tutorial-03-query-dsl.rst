Tutorial 3: Mastering the Query DSL
====================================

In this tutorial, you'll learn to write powerful, type-safe queries using LearnQL's static Field objects and expression templates. You'll master comparison operators, logical operators, and build complex filtering expressions for a real-world e-commerce system.

**Time**: 30 minutes
**Level**: Beginner to Intermediate
**Prerequisites**: Completed :doc:`tutorial-02-crud-operations`

What We'll Build
----------------

An e-commerce product filtering system with:

* Product catalog with various attributes
* Price range filtering using expression templates
* Category and tag-based searches
* Complex multi-condition queries using ``&&`` and ``||``
* Static Field objects for type-safe queries
* Lambda predicates for advanced filtering

Understanding LearnQL's Query API
----------------------------------

Static Fields vs. Lambda Predicates
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

LearnQL provides two powerful ways to query data:

**1. Static Field Expressions** - SQL-like syntax with compile-time safety:

.. code-block:: cpp

   // Using static Field objects (auto-generated by LEARNQL_PROPERTY)
   auto results = students.where(Student::age >= 21);
   auto cs_students = students.where(Student::department == "CS");

**2. Lambda Predicates** - Full C++ flexibility:

.. code-block:: cpp

   // Using lambda predicates for complex logic
   auto results = students.find_if([](const Student& s) {
       return s.get_age() >= 21 && s.get_gpa() > 3.5;
   });

.. note::
   Static Fields are auto-generated when you use ``LEARNQL_PROPERTY`` macros. Each property gets a corresponding static ``Field<T, FieldType>`` object that enables expression template queries.

How Expression Templates Work
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

When you write ``Student::age >= 21``:

1. ``Student::age`` is a static ``Field<Student, int>`` object
2. ``>= 21`` creates a comparison expression
3. The entire expression is type-checked at compile-time
4. Zero runtime overhead - optimized away by the compiler

.. code-block:: cpp

   Student::gpa > 3.5
   // Becomes internally:
   // BinaryExpression<Field<Student, double>, GreaterThan, Constant<3.5>>
   // Evaluated at compile-time for type safety!

Step 1: Define the Product Model
---------------------------------

Create ``product_search.cpp``:

.. code-block:: cpp

   #include <learnql/LearnQL.hpp>
   #include <iostream>
   #include <string>
   #include <iomanip>

   using namespace learnql;

   class Product {
       LEARNQL_PROPERTIES_BEGIN(Product)
           LEARNQL_PROPERTY(int, id, PK)
           LEARNQL_PROPERTY(std::string, name)
           LEARNQL_PROPERTY(std::string, category)
           LEARNQL_PROPERTY(double, price)
           LEARNQL_PROPERTY(int, stock_quantity)
           LEARNQL_PROPERTY(std::string, brand)
           LEARNQL_PROPERTY(bool, on_sale)
       LEARNQL_PROPERTIES_END(
           PROP(int, id, PK),
           PROP(std::string, name),
           PROP(std::string, category),
           PROP(double, price),
           PROP(int, stock_quantity),
           PROP(std::string, brand),
           PROP(bool, on_sale)
       )

   public:
       Product() = default;

       Product(int i, const std::string& n, const std::string& c, double p,
               int sq, const std::string& b, bool os)
           : id_(i), name_(n), category_(c), price_(p),
             stock_quantity_(sq), brand_(b), on_sale_(os) {}
   };

**Model breakdown:**

* ``id`` is the primary key (marked with ``PK``)
* ``price`` uses ``double`` for decimal precision
* ``on_sale`` is a boolean flag
* All properties automatically generate static Field objects

Step 2: Comparison Operators with Static Fields
------------------------------------------------

Equality and Inequality
~~~~~~~~~~~~~~~~~~~~~~~~

.. code-block:: cpp

   void find_exact_category(core::Table<Product>& products,
                           const std::string& category) {
       std::cout << "\n=== Products in category: " << category << " ===" << std::endl;

       // Equal to (==) with static Field
       auto results = products.where(Product::category == category);

       for (const auto& p : results) {
           std::cout << "  - " << p.get_name() << " ($" << p.get_price() << ")"
                     << std::endl;
       }
   }

   void find_not_on_sale(core::Table<Product>& products) {
       std::cout << "\n=== Regular Price Products ===" << std::endl;

       // Not equal to (!=)
       auto results = products.where(Product::on_sale != true);

       std::cout << "Found " << results.size() << " regular price items" << std::endl;
   }

Numeric Comparisons
~~~~~~~~~~~~~~~~~~~

.. code-block:: cpp

   void find_by_price_range(core::Table<Product>& products,
                            double min, double max) {
       std::cout << "\n=== Products between $" << min
                 << " and $" << max << " ===" << std::endl;

       // Greater than (>), Less than or equal (<=)
       auto results = products.where(
           (Product::price > min) && (Product::price <= max)
       );

       for (const auto& p : results) {
           std::cout << "  $" << std::fixed << std::setprecision(2)
                     << p.get_price() << " - " << p.get_name() << std::endl;
       }
   }

   void find_expensive_products(core::Table<Product>& products,
                                double threshold) {
       std::cout << "\n=== Premium Products (>= $" << threshold << ") ===" << std::endl;

       // Greater than or equal (>=)
       auto results = products.where(Product::price >= threshold);

       for (const auto& p : results) {
           std::cout << "  - " << p.get_name() << ": $" << p.get_price() << std::endl;
       }
   }

   void find_low_stock(core::Table<Product>& products) {
       std::cout << "\n=== Low Stock Alert (< 10 units) ===" << std::endl;

       // Less than (<)
       auto results = products.where(Product::stock_quantity < 10);

       for (const auto& p : results) {
           std::cout << "  - " << p.get_name() << ": "
                     << p.get_stock_quantity() << " remaining" << std::endl;
       }
   }

All Comparison Operators
~~~~~~~~~~~~~~~~~~~~~~~~~

+------------+---------------------------+---------------------------+
| Operator   | Meaning                   | Example                   |
+============+===========================+===========================+
| ``==``     | Equal to                  | ``Product::price == 99``  |
+------------+---------------------------+---------------------------+
| ``!=``     | Not equal to              | ``Product::category !=``  |
|            |                           | ``"Food"``                |
+------------+---------------------------+---------------------------+
| ``<``      | Less than                 | ``Product::stock < 5``    |
+------------+---------------------------+---------------------------+
| ``<=``     | Less than or equal        | ``Product::price <= 100`` |
+------------+---------------------------+---------------------------+
| ``>``      | Greater than              | ``Product::price > 50``   |
+------------+---------------------------+---------------------------+
| ``>=``     | Greater than or equal     | ``Product::price >= 50``  |
+------------+---------------------------+---------------------------+

Step 3: Logical Operators
--------------------------

AND Operator (``&&``)
~~~~~~~~~~~~~~~~~~~~~

Use ``&&`` when **all conditions** must be true:

.. code-block:: cpp

   void find_affordable_electronics(core::Table<Product>& products) {
       std::cout << "\n=== Affordable Electronics ===" << std::endl;

       // Both conditions must be true
       auto results = products.where(
           (Product::category == "Electronics") && (Product::price < 500)
       );

       for (const auto& p : results) {
           std::cout << "  - " << p.get_name() << " ($" << p.get_price() << ")"
                     << std::endl;
       }
   }

   void find_sale_items_in_stock(core::Table<Product>& products) {
       std::cout << "\n=== Sale Items In Stock ===" << std::endl;

       // Multiple AND conditions
       auto results = products.where(
           (Product::on_sale == true) &&
           (Product::stock_quantity > 0) &&
           (Product::price < 1000)
       );

       std::cout << "Found " << results.size() << " sale items available" << std::endl;
   }

OR Operator (``||``)
~~~~~~~~~~~~~~~~~~~~

Use ``||`` when **at least one condition** must be true:

.. code-block:: cpp

   void find_tech_or_gaming(core::Table<Product>& products) {
       std::cout << "\n=== Tech & Gaming Products ===" << std::endl;

       // Either condition can be true
       auto results = products.where(
           (Product::category == "Electronics") || (Product::category == "Gaming")
       );

       for (const auto& p : results) {
           std::cout << "  - " << p.get_name() << " [" << p.get_category() << "]"
                     << std::endl;
       }
   }

   void find_deals_or_popular(core::Table<Product>& products) {
       std::cout << "\n=== Deals or Popular Items ===" << std::endl;

       // Multiple OR conditions
       auto results = products.where(
           (Product::on_sale == true) || (Product::stock_quantity < 5)
       );

       std::cout << "Found " << results.size() << " items" << std::endl;
   }

Logical Operators Summary
~~~~~~~~~~~~~~~~~~~~~~~~~

+------------+---------------------------+---------------------------+
| Operator   | Logic                     | Example                   |
+============+===========================+===========================+
| ``&&``     | AND (all must be true)    | ``(Product::price > 10)`` |
|            |                           | ``&& (Product::stock >``  |
|            |                           | ``0)``                    |
+------------+---------------------------+---------------------------+
| ``||``     | OR (at least one true)    | ``(Product::on_sale) ||`` |
|            |                           | ``(Product::price < 20)`` |
+------------+---------------------------+---------------------------+

Step 4: Complex Nested Conditions
----------------------------------

Using Parentheses for Grouping
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

You can combine multiple operators with parentheses for complex logic:

.. code-block:: cpp

   void find_premium_deals(core::Table<Product>& products) {
       std::cout << "\n=== Premium Deals ===" << std::endl;

       // (High price OR premium brand) AND on sale
       auto results = products.where(
           ((Product::price > 500) || (Product::brand == "Apple")) &&
           (Product::on_sale == true)
       );

       for (const auto& p : results) {
           std::cout << "  - " << p.get_name() << " (" << p.get_brand() << "): $"
                     << p.get_price() << " [SALE]" << std::endl;
       }
   }

   void find_budget_or_clearance(core::Table<Product>& products) {
       std::cout << "\n=== Budget or Clearance Items ===" << std::endl;

       // (Cheap AND in stock) OR (expensive but very low stock)
       auto results = products.where(
           ((Product::price < 50) && (Product::stock_quantity > 10)) ||
           ((Product::price > 500) && (Product::stock_quantity < 3))
       );

       for (const auto& p : results) {
           std::cout << "  - " << p.get_name() << ": $" << p.get_price()
                     << " (stock: " << p.get_stock_quantity() << ")" << std::endl;
       }
   }

Real-World Complex Query
~~~~~~~~~~~~~~~~~~~~~~~~

.. code-block:: cpp

   void find_recommended_products(core::Table<Product>& products) {
       std::cout << "\n=== Recommended Products ===" << std::endl;

       // Complex business logic:
       // - Must be in stock (stock > 0)
       // - Either on sale, OR (price < 200 AND brand is Sony/Apple)
       // - Category must be Electronics or Gaming
       auto results = products.where(
           (Product::stock_quantity > 0) &&
           ((Product::on_sale == true) ||
            ((Product::price < 200) &&
             ((Product::brand == "Sony") || (Product::brand == "Apple")))) &&
           ((Product::category == "Electronics") || (Product::category == "Gaming"))
       );

       int count = 0;
       for (const auto& p : results) {
           std::cout << "  " << ++count << ". " << p.get_name()
                     << " - " << p.get_brand() << " ($" << p.get_price() << ")";
           if (p.get_on_sale()) std::cout << " [SALE]";
           std::cout << std::endl;

           if (count >= 10) break;  // Limit to 10
       }
   }

.. note::
   Use parentheses ``()`` to control the order of operations, just like in regular C++ expressions. This ensures your logic executes in the correct order.

Step 5: Lambda Predicates for Advanced Filtering
-------------------------------------------------

When Expression Templates Aren't Enough
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

For complex logic that can't be expressed with static Fields, use ``find_if()`` with lambda predicates:

.. code-block:: cpp

   void find_with_lambda(core::Table<Product>& products) {
       std::cout << "\n=== Advanced Lambda Filtering ===" << std::endl;

       // Complex string operations, calculations, etc.
       auto results = products.find_if([](const Product& p) {
           // Check if name contains "Pro"
           bool is_pro = p.get_name().find("Pro") != std::string::npos;

           // Calculate discount percentage
           bool good_deal = p.get_on_sale() && p.get_price() < 300;

           // Multiple getters
           return is_pro && good_deal && p.get_stock_quantity() > 5;
       });

       for (const auto& p : results) {
           std::cout << "  - " << p.get_name() << " ($" << p.get_price() << ")"
                     << std::endl;
       }
   }

Combining Both Approaches
~~~~~~~~~~~~~~~~~~~~~~~~~

.. code-block:: cpp

   void find_smart_filtering(core::Table<Product>& products) {
       std::cout << "\n=== Smart Filtering (Mixed Approach) ===" << std::endl;

       // Use static Fields for simple filtering first
       auto electronics = products.where(Product::category == "Electronics");

       // Then use lambda for complex logic
       std::vector<Product> filtered;
       for (const auto& p : electronics) {
           // Complex calculations that can't be done in expression templates
           double price_per_unit = p.get_price() / std::max(1, p.get_stock_quantity());

           if (price_per_unit < 50 && !p.get_on_sale()) {
               filtered.push_back(p);
           }
       }

       std::cout << "Found " << filtered.size() << " products" << std::endl;
   }

Step 6: Complete E-Commerce Search Program
-------------------------------------------

.. code-block:: cpp

   #include <learnql/LearnQL.hpp>
   #include <iostream>
   #include <string>
   #include <iomanip>

   using namespace learnql;

   class Product {
       LEARNQL_PROPERTIES_BEGIN(Product)
           LEARNQL_PROPERTY(int, id, PK)
           LEARNQL_PROPERTY(std::string, name)
           LEARNQL_PROPERTY(std::string, category)
           LEARNQL_PROPERTY(double, price)
           LEARNQL_PROPERTY(int, stock_quantity)
           LEARNQL_PROPERTY(std::string, brand)
           LEARNQL_PROPERTY(bool, on_sale)
       LEARNQL_PROPERTIES_END(
           PROP(int, id, PK),
           PROP(std::string, name),
           PROP(std::string, category),
           PROP(double, price),
           PROP(int, stock_quantity),
           PROP(std::string, brand),
           PROP(bool, on_sale)
       )

   public:
       Product() = default;

       Product(int i, const std::string& n, const std::string& c, double p,
               int sq, const std::string& b, bool os)
           : id_(i), name_(n), category_(c), price_(p),
             stock_quantity_(sq), brand_(b), on_sale_(os) {}
   };

   void add_sample_products(core::Table<Product>& products) {
       std::cout << "Adding sample products..." << std::endl;

       products.insert(Product(1, "iPhone 15 Pro", "Electronics", 999.99, 15, "Apple", true));
       products.insert(Product(2, "MacBook Air M2", "Electronics", 1199.99, 8, "Apple", false));
       products.insert(Product(3, "Sony WH-1000XM5", "Electronics", 349.99, 25, "Sony", true));
       products.insert(Product(4, "Samsung Galaxy S24", "Electronics", 799.99, 20, "Samsung", true));
       products.insert(Product(5, "PlayStation 5", "Gaming", 499.99, 3, "Sony", false));
       products.insert(Product(6, "Xbox Series X", "Gaming", 499.99, 5, "Microsoft", false));
       products.insert(Product(7, "Nintendo Switch", "Gaming", 299.99, 30, "Nintendo", true));
       products.insert(Product(8, "Logitech MX Master", "Electronics", 99.99, 50, "Logitech", false));
       products.insert(Product(9, "Kindle Paperwhite", "Electronics", 139.99, 40, "Amazon", true));
       products.insert(Product(10, "AirPods Pro", "Electronics", 249.99, 12, "Apple", true));

       std::cout << "Added " << products.size() << " products" << std::endl;
   }

   void display_products(const auto& results, const std::string& title) {
       std::cout << "\n" << std::string(80, '=') << std::endl;
       std::cout << title << std::endl;
       std::cout << std::string(80, '=') << std::endl;

       if (results.empty()) {
           std::cout << "No products found." << std::endl;
           return;
       }

       for (const auto& p : results) {
           std::cout << std::setw(3) << p.get_id() << " | "
                     << std::setw(25) << std::left << p.get_name()
                     << " | " << std::setw(12) << p.get_category()
                     << " | $" << std::setw(7) << std::right << std::fixed
                     << std::setprecision(2) << p.get_price()
                     << " | Stock: " << std::setw(3) << p.get_stock_quantity()
                     << " | " << p.get_brand();
           if (p.get_on_sale()) std::cout << " [SALE]";
           std::cout << std::endl;
       }
       std::cout << "\nTotal: " << results.size() << " products\n" << std::endl;
   }

   int main() {
       try {
           core::Database db("ecommerce.db");
           auto& products = db.table<Product>("products");

           if (products.size() == 0) {
               add_sample_products(products);
           }

           // Demo 1: Simple price filter
           auto affordable = products.where(Product::price < 300);
           display_products(affordable, "Affordable Products (< $300)");

           // Demo 2: Category filter
           auto electronics = products.where(Product::category == "Electronics");
           display_products(electronics, "Electronics Category");

           // Demo 3: AND operator
           auto sale_electronics = products.where(
               (Product::category == "Electronics") && (Product::on_sale == true)
           );
           display_products(sale_electronics, "Electronics on Sale");

           // Demo 4: OR operator
           auto tech_or_gaming = products.where(
               (Product::category == "Electronics") || (Product::category == "Gaming")
           );
           display_products(tech_or_gaming, "Tech & Gaming Products");

           // Demo 5: Complex query with parentheses
           auto premium_deals = products.where(
               ((Product::price > 500) || (Product::brand == "Apple")) &&
               (Product::on_sale == true) &&
               (Product::stock_quantity > 0)
           );
           display_products(premium_deals, "Premium Deals Available");

           // Demo 6: Price range
           auto mid_range = products.where(
               (Product::price >= 200) && (Product::price <= 500)
           );
           display_products(mid_range, "Mid-Range Products ($200-$500)");

           // Demo 7: Low stock alert
           auto low_stock = products.where(Product::stock_quantity < 10);
           display_products(low_stock, "Low Stock Alert (< 10 units)");

           // Demo 8: Lambda predicate for complex filtering
           std::cout << "\n=== Lambda Filtering: Products with 'Pro' in name ===" << std::endl;
           auto pro_products = products.find_if([](const Product& p) {
               return p.get_name().find("Pro") != std::string::npos;
           });

           for (const auto& p : pro_products) {
               std::cout << "  - " << p.get_name() << " ($" << p.get_price() << ")"
                         << std::endl;
           }

           return 0;
       } catch (const std::exception& e) {
           std::cerr << "Error: " << e.what() << std::endl;
           return 1;
       }
   }

Build and run:

.. code-block:: bash

   mkdir build && cd build
   cmake ..
   cmake --build .
   ./product_search

Query Patterns Cheat Sheet
---------------------------

Common Query Patterns
~~~~~~~~~~~~~~~~~~~~~

.. code-block:: cpp

   // 1. Simple equality with static Field
   products.where(Product::category == "Electronics")

   // 2. Range query
   products.where((Product::price >= 100) && (Product::price <= 500))

   // 3. Multiple conditions (AND)
   products.where((Product::on_sale == true) && (Product::stock > 0))

   // 4. Alternative conditions (OR)
   products.where((Product::category == "A") || (Product::category == "B"))

   // 5. Complex nested conditions
   products.where(
       ((Product::price < 100) || (Product::on_sale == true)) &&
       (Product::stock > 0)
   )

   // 6. Lambda predicate for advanced filtering
   products.find_if([](const Product& p) {
       return p.get_price() > 100 && p.get_name().length() > 10;
   })

   // 7. Combining static Fields and lambda
   auto filtered = products.where(Product::category == "Electronics");
   for (const auto& p : filtered) {
       if (complex_condition(p)) {
           // Process...
       }
   }

What You Learned
----------------

✅ Using static Field objects for type-safe queries (``Product::price``)

✅ Expression templates with zero runtime overhead

✅ Comparison operators (``==``, ``!=``, ``<``, ``>``, ``<=``, ``>=``)

✅ Combining conditions with ``&&`` (AND)

✅ Alternative conditions with ``||`` (OR)

✅ Creating complex nested queries with parentheses

✅ Lambda predicates with ``find_if()`` for advanced filtering

✅ Mixing static Fields and lambda predicates

✅ Building real-world filtering systems

✅ Type safety at compile-time

Exercises
---------

Try these challenges to master the Query DSL:

1. **Multi-brand filter**

   .. code-block:: cpp

      // Find products from Apple, Sony, or Samsung
      // Hint: Use || to combine brand conditions

2. **Price tier classification**

   Create functions to categorize products:

   * Budget: < $100
   * Mid-range: $100-$500
   * Premium: > $500

3. **Smart inventory query**

   .. code-block:: cpp

      // Find products that need reordering:
      // - Stock < 10 AND NOT on sale
      // - OR stock < 5 regardless of sale status

4. **Category exclusion**

   .. code-block:: cpp

      // Find all products EXCEPT Electronics and Gaming
      // Hint: Use != with &&

5. **Value deals finder**

   .. code-block:: cpp

      // Find "value deals":
      // - On sale OR price < $150
      // - AND stock > 20
      // - AND category is Electronics

Next Steps
----------

Continue to :doc:`tutorial-04-joins-relationships` to learn how to work with related data using LearnQL's Join API, implement inner and left joins, and model complex relationships between tables.

.. tip::
   The Query DSL is type-safe - if you make a mistake (like comparing a string with a number), the compiler will catch it! Experiment with invalid queries to see the compile-time error messages.
